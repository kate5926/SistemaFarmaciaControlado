-- Crear base de datos
--CREATE DATABASE pharmacy_control;
-- Eliminar base de datos si existe
DROP DATABASE IF EXISTS pharmacy_regulatorycontro;

-- Crear base de datos
CREATE DATABASE pharmacy_regulatorycontrol;

-- 1. medicamentos
CREATE TABLE medicamentos (
    id SERIAL PRIMARY KEY,
    nombre VARCHAR(255) NOT NULL,
    tipo VARCHAR(20) CHECK (tipo IN ('Común', 'Controlado')),
    descripcion TEXT,
    precio DECIMAL(10,2)
);

-- 2. lotes
CREATE TABLE lotes (
    id SERIAL PRIMARY KEY,
    medicamento_id INT REFERENCES medicamentos(id),
    lote_numero VARCHAR(100) UNIQUE,
    fecha_vencimiento DATE,
    stock INT,
    fecha_ingreso DATE DEFAULT CURRENT_DATE
);

-- 4. medicos
CREATE TABLE medicos (
    id SERIAL PRIMARY KEY,
    nombre VARCHAR(255) NOT NULL,
    especialidad VARCHAR(100),
    cmp VARCHAR(20) UNIQUE
);


-- 4. pacientes (sin encriptación, campos TEXT)
CREATE TABLE pacientes (
    id SERIAL PRIMARY KEY,
    nombre VARCHAR(255),                   -- Visible
    dni VARCHAR(8) UNIQUE,                 -- Visible
    direccion TEXT,                        -- Datos sensibles (sin encriptar por ahora)
    telefono TEXT,                         -- Datos sensibles
    alergias TEXT,                         -- Datos sensibles
    historial_medico TEXT,                 -- Datos sensibles
    fecha_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 5. recetas (sin encriptación, campos TEXT)
CREATE TABLE recetas (
    id SERIAL PRIMARY KEY,
    paciente_id INT REFERENCES pacientes(id),
    medico_id INT REFERENCES medicos(id),
    fecha_emision DATE,                    -- Visible
    fecha_vencimiento DATE,                -- Visible
    diagnostico TEXT,                      -- Datos sensibles (sin encriptar)
    tratamiento TEXT,                      -- Datos sensibles
    instrucciones TEXT,                    -- Datos sensibles
    observaciones TEXT,                    -- Datos sensibles
    estado VARCHAR(20) DEFAULT 'Válida' CHECK (estado IN ('Válida', 'Usada', 'Vencida'))
);

-- 6. ventas
CREATE TABLE ventas (
    id SERIAL PRIMARY KEY,
    receta_id INT REFERENCES recetas(id),
    fecha_venta TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    usuario VARCHAR(50) NOT NULL
);

-- 7. detalles_venta
CREATE TABLE detalles_venta (
    id SERIAL PRIMARY KEY,
    venta_id INT REFERENCES ventas(id),
    lote_id INT REFERENCES lotes(id),
    medicamento_id INT REFERENCES medicamentos(id),
    cantidad INT NOT NULL CHECK (cantidad > 0),
    precio_unitario DECIMAL(10,2)
);

-- 8. auditoria_controlados
CREATE TABLE auditoria_controlados (
    id SERIAL PRIMARY KEY,
    venta_id INT REFERENCES ventas(id),
    medicamento_controlado_id INT REFERENCES medicamentos(id),
    paciente_id INT REFERENCES pacientes(id),
    medico_id INT REFERENCES medicos(id),
    cantidad_dispensada INT NOT NULL,
    usuario_que_dispenso VARCHAR(50) NOT NULL,
    fecha_dispensacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    numero_receta VARCHAR(100),
    motivo_consulta TEXT
);

-- 9. alertas_vencimiento
CREATE TABLE alertas_vencimiento (
    id SERIAL PRIMARY KEY,
    lote_id INT REFERENCES lotes(id),
    mensaje TEXT,
    fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


-- ÍNDICES  PARA REQUISITO 2

CREATE INDEX idx_medicamentos ON medicamentos USING btree(nombre, tipo);
CREATE INDEX idx_lotes ON lotes USING btree(medicamento_id, fecha_vencimiento);
CREATE INDEX idx_fechas_vencimiento ON lotes USING btree(fecha_vencimiento) WHERE stock > 0;
CREATE INDEX idx_recetas ON recetas USING btree(paciente_id, fecha_emision);


-- Trigger REQUISITO 4
CREATE OR REPLACE FUNCTION alerta_vencimiento() RETURNS TRIGGER AS $$
BEGIN
    -- Solo generar alerta si tiene stock disponible
    IF NEW.fecha_vencimiento <= CURRENT_DATE + INTERVAL '30 days' AND NEW.stock > 0 THEN
        INSERT INTO alertas_vencimiento (lote_id, mensaje) 
        VALUES (
            NEW.id, 
            'ALERTA: Lote ' || NEW.lote_numero || ' vence el ' || NEW.fecha_vencimiento || ' - Stock: ' || NEW.stock
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_alerta_vencimiento
AFTER INSERT OR UPDATE ON lotes
FOR EACH ROW EXECUTE FUNCTION alerta_vencimiento();


--INSERCION DE DATOS
-- Más medicamentos
INSERT INTO medicamentos (nombre, tipo, descripcion, precio) VALUES 
('Aspirina', 'Común', 'Analgésico', 2.50),
('Codeína', 'Controlado', 'Analgésico fuerte', 12.00),
('Ibuprofeno', 'Común', 'Antiinflamatorio', 3.00),
('Amoxicilina', 'Controlado', 'Antibiótico', 8.00);


-- Pacientes (datos sensibles en TEXT)
INSERT INTO pacientes (nombre, dni, direccion, telefono, alergias, historial_medico) VALUES 
('Juan Pérez', '12345678', 'Calle 123', '987654321', 'Ninguna', 'Cirugía 2020'),
('María López', '87654321', 'Av. Principal', '999888777', 'Penicilina', 'Diabetes'),
('Carlos García', '11223344', 'Plaza Central', '888777666', 'Sulfa', 'Fractura');

-- Recetas (datos sensibles en TEXT)
INSERT INTO recetas (paciente_id, medico_id, fecha_emision, fecha_vencimiento, diagnostico, tratamiento, instrucciones, observaciones) VALUES 
(1, 1, '2024-10-01', '2024-11-01', 'Dolor de cabeza', 'Tomar aspirina', 'Cada 8 horas', 'Mejorando'),
(2, 2, '2024-10-15', '2024-11-15', 'Fiebre', 'Reposo', 'Tomar líquidos', 'Control en 3 días');


-- Más recetas (sin campos encriptados)
INSERT INTO recetas (paciente_id, medico_id, fecha_emision, fecha_vencimiento) VALUES 
(1, 1, '2024-10-01', '2024-11-01'),
(2, 2, '2024-10-15', '2024-11-15');

-- 6. INSERTAR LOTES USANDO LOS IDs REALES
INSERT INTO lotes (medicamento_id, lote_numero, fecha_vencimiento, stock) 
SELECT 1, 'LOTE001', '2025-12-31', 100
WHERE EXISTS (SELECT 1 FROM medicamentos WHERE id = 1);

INSERT INTO lotes (medicamento_id, lote_numero, fecha_vencimiento, stock) 
SELECT 1, 'LOTE002', '2024-12-15', 50  ----activa alecta
WHERE EXISTS (SELECT 1 FROM medicamentos WHERE id = 4);

INSERT INTO lotes (medicamento_id, lote_numero, fecha_vencimiento, stock) 
SELECT 2, 'LOTE003', '2025-06-30', 80
WHERE EXISTS (SELECT 1 FROM medicamentos WHERE id = 2);

INSERT INTO lotes (medicamento_id, lote_numero, fecha_vencimiento, stock) 
SELECT 3, 'LOTE004', '2024-11-20', 30 ----activa alerta
WHERE EXISTS (SELECT 1 FROM medicamentos WHERE id = 3);

--- VENTAS 
-- Ventas y detalles para pruebas
INSERT INTO ventas (receta_id, usuario) VALUES 
(1, 'usuario1');

INSERT INTO detalles_venta (venta_id, lote_id, medicamento_id, cantidad, precio_unitario) VALUES 
(1, 1, 1, 5, 2.50);

-- Auditoría
INSERT INTO auditoria_controlados (venta_id, medicamento_controlado_id, paciente_id, medico_id, cantidad_dispensada, usuario_que_dispenso, numero_receta, motivo_consulta) VALUES 
(1, 2, 1, 1, 3, 'usuario1', 'REC001', 'Dolor crónico');

-- Consultas de verificación
SELECT 'DATOS INSERTADOS:' as seccion;
SELECT 'Médicos: ' || COUNT(*) FROM medicos
UNION ALL SELECT 'Pacientes: ' || COUNT(*) FROM pacientes
UNION ALL SELECT 'Medicamentos: ' || COUNT(*) FROM medicamentos
UNION ALL SELECT 'Lotes: ' || COUNT(*) FROM lotes
UNION ALL SELECT 'Recetas: ' || COUNT(*) FROM recetas
UNION ALL SELECT 'Ventas: ' || COUNT(*) FROM ventas
UNION ALL SELECT 'Alertas: ' || COUNT(*) FROM alertas_vencimiento;

---INVENTARIO
SELECT 'INVENTARIO:' as seccion;
SELECT m.nombre, m.tipo, l.lote_numero, l.stock, l.fecha_vencimiento,
       CASE WHEN l.fecha_vencimiento <= CURRENT_DATE + INTERVAL '30 days' THEN 'VENCE PRONTO' 
            WHEN l.stock < 10 THEN ' STOCK BAJO'
            ELSE ' NORMAL' END as estado
FROM medicamentos m
JOIN lotes l ON m.id = l.medicamento_id
ORDER BY l.fecha_vencimiento;

--INDICES
SELECT 'ÍNDICES OPTIMIZADOS:' as seccion;
SELECT indexname, tablename FROM pg_indexes 
WHERE schemaname = 'public' AND indexname LIKE 'idx%';
